{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome! Welcome to R4A APIs! From here you can write applications that use a device's hardware, cloud services and generic functionalities. This is possible via the three distinct APIs (Robot, Cloud and Generic). Furthermore, you can write higher-level apps (FSM-like) using the TekNodes module. In this documentation you may find: Utilities: Various stuff, useful for writing applications. These are: Messages : How to give input and take output from services/API calls. Memory : How to store and retrieve variables/data from device memory Conditions : How to create conditions that use variables or constants Enumerations : What variables and enumerations are available Robot API : Calls to manipulate Robots and Devices Cloud API : Calls to get information from cloud services Generic API : Generic functionality like delays etc. FSM-like applications : How to write applications using an FSM-like way Examples : Various examples Have a nice reading ;)","title":"Home"},{"location":"#welcome","text":"Welcome to R4A APIs! From here you can write applications that use a device's hardware, cloud services and generic functionalities. This is possible via the three distinct APIs (Robot, Cloud and Generic). Furthermore, you can write higher-level apps (FSM-like) using the TekNodes module. In this documentation you may find: Utilities: Various stuff, useful for writing applications. These are: Messages : How to give input and take output from services/API calls. Memory : How to store and retrieve variables/data from device memory Conditions : How to create conditions that use variables or constants Enumerations : What variables and enumerations are available Robot API : Calls to manipulate Robots and Devices Cloud API : Calls to get information from cloud services Generic API : Generic functionality like delays etc. FSM-like applications : How to write applications using an FSM-like way Examples : Various examples Have a nice reading ;)","title":"Welcome!"},{"location":"cloudapi/","text":"Under construction...","title":"Cloud API"},{"location":"conditions/","text":"Under construction...","title":"Conditions"},{"location":"enums/","text":"Under construction...","title":"Enumerations"},{"location":"examples/","text":"Under construction...","title":"Examples"},{"location":"exceptions/","text":"The TekException class We also have custom exceptions that handle errors that occur in the R4A API. These are TekException objects that exist in the utilities module. In order to raise an exception you can write: from utilities import TekException raise TekException(\"String that explains the error\") In order to catch TekExceptions you can write something like this: try: pass # Code here except TekException: pass # Catches only TekExceptions except Exception: pass # Catches all other exceptions Each time a TekException is raised, a message is printed in console, containing information about which function raised the exception, in what line and what is the error message.","title":"Exceptions"},{"location":"exceptions/#the-tekexception-class","text":"We also have custom exceptions that handle errors that occur in the R4A API. These are TekException objects that exist in the utilities module. In order to raise an exception you can write: from utilities import TekException raise TekException(\"String that explains the error\") In order to catch TekExceptions you can write something like this: try: pass # Code here except TekException: pass # Catches only TekExceptions except Exception: pass # Catches all other exceptions Each time a TekException is raised, a message is printed in console, containing information about which function raised the exception, in what line and what is the error message.","title":"The TekException class"},{"location":"genericapi/","text":"Under construction...","title":"Generic API"},{"location":"memory/","text":"Under construction...","title":"Memory"},{"location":"messages/","text":"Introduction There are two classes to handle input and output, which can be found in the utilities module. These are InputMessage and OutputMessage . InputMessage class You can create an input message as such: from utilities import InputMessage i = InputMessage() Every input message contains the following: timestamp : Contains the timestamp of the message's creation data : The data. This usually is a Python dictionary. print() : Function to print the input message An example follows: from utilities import InputMessage i = InputMessage({'duration': 3}) i.data['another'] = 2 i.print() The output in console is: Input message: [1575288958.9064102] Data: {'duration': 3, 'another': 2} OutputMessage class Every call of the Robot, Cloud or Generic API returns an OutputMessage . Each output message contains: timestamp : Contains the timestamp of the message's creation sequence : A unique number that characterizes the message errors : A list of possible errors logs : A list of logs. Usually contains trace-back information. data : The data that the message contains print() : Prints the output message An example code that utilizes an output message is the following: from utilities import Devices, InputMessage from robot_api import RobotAPI rapi = RobotAPI() rapi.devicesObj.enableDevicesType(Devices.TOUCH_SCREEN) out = rapi.showOptions(InputMessage({ 'options': ['Option 1', 'Option 2'], 'duration': 5 })) out.print() This snippet initializes a touch screen, shows 2 options and waits for 5 seconds for the user to select one. The output is: Output message: [1575290784.5641167] #5 {'reaction_time': 0.9212639331817627, 'selected': 'Option 1'} Errors: Logs: [1575290784.5652816] setOptions @ RobotAPITouchScreenController [1575290784.5658484] showOptions @ RobotAPI","title":"Messages"},{"location":"messages/#introduction","text":"There are two classes to handle input and output, which can be found in the utilities module. These are InputMessage and OutputMessage .","title":"Introduction"},{"location":"messages/#inputmessage-class","text":"You can create an input message as such: from utilities import InputMessage i = InputMessage() Every input message contains the following: timestamp : Contains the timestamp of the message's creation data : The data. This usually is a Python dictionary. print() : Function to print the input message An example follows: from utilities import InputMessage i = InputMessage({'duration': 3}) i.data['another'] = 2 i.print() The output in console is: Input message: [1575288958.9064102] Data: {'duration': 3, 'another': 2}","title":"InputMessage class"},{"location":"messages/#outputmessage-class","text":"Every call of the Robot, Cloud or Generic API returns an OutputMessage . Each output message contains: timestamp : Contains the timestamp of the message's creation sequence : A unique number that characterizes the message errors : A list of possible errors logs : A list of logs. Usually contains trace-back information. data : The data that the message contains print() : Prints the output message An example code that utilizes an output message is the following: from utilities import Devices, InputMessage from robot_api import RobotAPI rapi = RobotAPI() rapi.devicesObj.enableDevicesType(Devices.TOUCH_SCREEN) out = rapi.showOptions(InputMessage({ 'options': ['Option 1', 'Option 2'], 'duration': 5 })) out.print() This snippet initializes a touch screen, shows 2 options and waits for 5 seconds for the user to select one. The output is: Output message: [1575290784.5641167] #5 {'reaction_time': 0.9212639331817627, 'selected': 'Option 1'} Errors: Logs: [1575290784.5652816] setOptions @ RobotAPITouchScreenController [1575290784.5658484] showOptions @ RobotAPI","title":"OutputMessage class"},{"location":"nodes/","text":"Under construction...","title":"FSM-like applications"},{"location":"robotapi/","text":"Under construction...Under construction...","title":"Robot API"}]}